#!/usr/bin/env ruby
require 'gli'
require 'logger/colors'
require 'curses'
require 'dopi'
require 'yaml'
require 'fileutils'

module Wrapper
  include GLI::App

  extend self

  program_desc 'DOPi Command line Client'
  version Dopi::VERSION

  subcommand_option_handling :normal
  arguments :strict

  desc 'Verbosity of the command line tool'
  default_value 'INFO'
  arg_name 'Verbosity'
  flag [:verbosity, :v]

  desc 'Show stacktrace on crash'
  default_value Dopi.configuration.trace
  switch [:trace, :t]

  #
  # DOPi Configuration
  #
  config_file Dopi.configuration.config_file

  desc 'Specify the directory where DOPi will cache data about the plans'
  default_value Dopi.configuration.plan_cache_dir
  arg_name 'DIR'
  flag [:plan_cache_dir, :p]

  desc 'Use Hiera to get the role for the nodes'
  default_value Dopi.configuration.use_hiera
  switch [:use_hiera, :h]

  desc 'Specify the hiera configuration file'
  default_value Dopi.configuration.hiera_yaml
  arg_name 'YAML'
  flag [:hiera_yaml]

  desc 'Try to load the scope for the nodes from existing facts'
  default_value Dopi.configuration.load_facts
  switch [:load_facts]

  desc 'Specify the directory where dopi can find facts'
  default_value Dopi.configuration.facts_dir
  arg_name 'DIR'
  flag [:facts_dir]

  desc 'Set the name of the variable DOPi should use as the roles variable'
  default_value Dopi.configuration.role_variable
  arg_name 'VARIABLE_NAME'
  flag [:role_variable]

  desc 'Set the default value for the node role'
  default_value Dopi.configuration.role_default
  arg_name 'ROLE'
  flag [:role_default]

  desc 'Set the default ssh user (DEPRECATED: Use the credentials hash method)'
  default_value Dopi.configuration.ssh_user
  arg_name 'USERNAME'
  flag [:ssh_user]

  desc 'Set the default ssh key (DEPRECATED: Use the credentials hash method)'
  default_value Dopi.configuration.ssh_key
  arg_name 'SSHKEY'
  flag [:ssh_key]

  desc 'Allow ssh logins with password (DEPRECATED: Use the credentials hash method)'
  default_value Dopi.configuration.ssh_pass_auth
  switch [:ssh_pass_auth]

  desc 'Force ssh to check the host keys (this is disabled by default because we usually deal with new hosts)'
  default_value Dopi.configuration.ssh_check_host_key
  switch [:ssh_check_host_key]

  desc 'Set the MCollective client configuration.'
  default_value Dopi.configuration.mco_config
  arg_name 'FILE'
  flag [:mco_config]

  desc 'Use the DOPi logger to capture MCollective logs (this is enabled by default)'
  default_value Dopi.configuration.mco_dopi_logger
  switch [:mco_dopi_logger]

  desc 'Time until a connection check is marked as failure'
  default_value Dopi.configuration.connection_check_timeout
  arg_name 'SECONDS'
  flag [:connection_check_timeout]

  pre do |global,command,options,args|
    Dopi.configure do |config|
      config.trace =              global[:trace]
      config.plan_cache_dir =     global[:plan_cache_dir]
      config.use_hiera =          global[:use_hiera]
      config.hiera_yaml =         global[:hiera_yaml]
      config.facts_dir =          global[:facts_dir]
      config.load_facts =         global[:load_facts]
      config.role_variable =      global[:role_variable]
      config.role_default =       global[:role_default]
      config.ssh_user =           global[:ssh_user]
      config.ssh_key =            global[:ssh_key]
      config.ssh_pass_auth =      global[:ssh_pass_auth]
      config.ssh_check_host_key = global[:ssh_check_host_key]
      config.mco_config         = global[:mco_config]
      config.mco_dopi_logger    = global[:mco_dopi_logger]
      config.connection_check_timeout = global[:connection_check_timeout]
    end
    ENV['GLI_DEBUG'] = 'true' if global[:trace] == true
    Dopi.logger = Logger.new(STDERR)
    Dopi.log.level = ::Logger.const_get(global[:verbosity].upcase)
    @plan_cache = DopCommon::PlanCache.new(global[:plan_cache_dir])
    true
  end

  def state(plan)
    result = "[#{plan.state.to_s}] #{plan.name}\n"
    plan.steps.each do |step|
      result << "  [#{step.state.to_s}] #{step.name}\n"
      step.commands.each do |command|
        result << "    [#{command.state.to_s}] #{command.node.name}\n"
      end
    end
    return result
  end

  def print_state(plan)
    puts state(plan)
  end

  desc 'Validate a plan file'
  arg_name 'plan_file'
  command :validate do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan file to add') if args.empty?
      help_now!('You can only add one plan') if args.length > 1
      if Dopi.plan_valid?(args[0])
        puts "Plan is valid"
      else
        exit_now!("Plan is NOT valid")
      end
    end
  end

  desc 'Add a new plan file to the plan cache'
  arg_name 'plan_file'
  command :add do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan file to add') if args.empty?
      help_now!('You can only add one plan') if args.length > 1
      plan = Dopi.add_plan(args[0])
      puts plan.name
    end
  end

  desc 'Show the list of plans in the dopi plan cache'
  command :list do |c|
    c.action do |global_options,options,args|
      puts @plan_cache.list()
    end
  end

  desc 'Remove an existing plan from the plan cache'
  arg_name 'name'
  command :remove do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan id to remove') if args.empty?
      help_now!('You can only remove one plan') if args.length > 1
      @plan_cache.remove(args[0])
    end
  end

  desc 'Show plan details and state'
  arg_name 'name'
  command :show do |c|
    c.desc 'Do not exit and continuously update the display'
    c.default_value false
    c.switch [:follow, :f]

    c.action do |global_options,options,args|
      help_now!('Specify a plan name to show') if args.empty?
      help_now!('You can only show one plan') if args.length > 1
      if options[:follow]
        begin
          Curses.noecho
          Curses.curs_set(0)
          Curses.init_screen
          plan = Dopi.load_plan(args[0])
          while true
            begin
              reload_plan = Dopi.load_plan(args[0])
              plan = reload_plan if reload_plan.kind_of?(Dopi::Plan)
            rescue
            end
            Curses.setpos(0, 0)
            Curses.addstr(state(plan))
            Curses.refresh
            sleep(1)
          end
        ensure
          Curses.close_screen
        end
      else
        print_state(Dopi.load_plan(args[0]))
      end
    end
  end

  desc 'Run the plan'
  arg_name 'id'
  command :run do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan name to run') if args.empty?
      help_now!('You can only run one plan') if args.length > 1
      plan = Dopi.load_plan(args[0])
      begin
        Dopi.run_plan(plan)
      rescue Dopi::StateTransitionError => e
        Dopi.log.error(e.message)
        exit_now!("Some steps are in a state where they can't be started again. Try to reset the plan.")
      ensure
        print_state(plan)
      end
    end
  end

  desc 'Reset a failed plan'
  arg_name 'name'
  command :reset do |c|
    c.desc 'Force reset the states back to ready from every state'
    c.default_value false
    c.switch [:force, :f]

    c.action do |global_options,options,args|
      help_now!('Specify a plan name to run') if args.empty?
      help_now!('You can only run one plan') if args.length > 1
      plan = Dopi.load_plan(args[0])
      plan.state_reset_with_children(options[:force])
      Dopi.save_plan(plan)
      print_state(plan)
    end
  end

  desc 'Add a plan, run it and then remove it again (This is mainly for testing)'
  arg_name 'plan_file'
  command :oneshot do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan file to add') if args.empty?
      help_now!('You can only add one plan') if args.length > 1
      begin
        plan = Dopi.add_plan(args[0])
        begin
          Dopi.run_plan(plan)
          sleep(2) # allow the show command to catch up
        ensure print_state(plan)
        end
      ensure @plan_cache.remove(plan.name) unless plan.nil?
      end
    end
  end

  exit run(ARGV)
end
