#!/usr/bin/env ruby
require 'gli'
require 'dopi'
require 'yaml'
require 'fileutils'

module Wrapper
  include GLI::App

  extend self

  program_desc 'DOPi Command line Client'
  version Dopi::VERSION

  subcommand_option_handling :normal
  arguments :strict

  desc 'Verbosity of the command line tool'
  default_value 'WARN'
  arg_name 'Verbosity'
  flag [:v,:verbosity]

  desc 'Show stacktrace on crash'
  switch [:t,:trace]

  #
  # DOPi Configuration
  #
  config_file Dopi.configuration.config_file

  desc 'Specify the directory where DOPi will cache data about the plans'
  default_value Dopi.configuration.plan_cache_dir
  arg_name 'DIR'
  flag [:p,:plan_cache_dir]

  desc 'Use Hiera to get the role for the nodes'
  default_value Dopi.configuration.use_hiera
  switch [:h,:use_hiera]

  desc 'Specify the hiera configuration file'
  default_value Dopi.configuration.hiera_yaml
  arg_name 'YAML'
  flag [:hiera_yaml]

  desc 'Try to load the scope for the nodes from existing facts'
  default_value Dopi.configuration.load_facts
  switch [:load_facts]

  desc 'Specify the directory where dopi can find facts'
  default_value Dopi.configuration.facts_dir
  arg_name 'DIR'
  flag [:facts_dir]

  desc 'Set the name of the variable DOPi should use as the roles variable'
  default_value Dopi.configuration.role_variable
  arg_name 'VARIABLE_NAME'
  flag [:role_variable]

  desc 'Set the default value for the node role'
  default_value Dopi.configuration.role_default
  arg_name 'ROLE'
  flag [:role_default]

  desc 'Set the default ssh user'
  default_value Dopi.configuration.ssh_user
  arg_name 'USERNAME'
  flag [:ssh_user]

  desc 'Set the default ssh key'
  default_value Dopi.configuration.ssh_key
  arg_name 'SSHKEY'
  flag [:ssh_key]

  desc 'Allow ssh logins with password (this is disabled by default. This will need the sshpass tool to be installed)'
  default_value Dopi.configuration.ssh_pass_auth
  switch [:ssh_pass_auth]

  desc 'Force ssh to check the host keys (this is disabled by default because we usually deal with new hosts)'
  default_value Dopi.configuration.ssh_check_host_key
  switch [:ssh_check_host_key]

  pre do |global,command,options,args|
    Dopi.configure do |config|
      config.plan_cache_dir =     global[:plan_cache_dir]
      config.hiera_yaml =         global[:hiera_yaml]
      config.facts_dir =          global[:facts_dir]
      config.load_facts =         global[:load_facts]
      config.role_variable =      global[:role_variable]
      config.role_default =       global[:role_default]
      config.ssh_user =           global[:ssh_user]
      config.ssh_key =            global[:ssh_key]
      config.ssh_pass_auth =      global[:ssh_pass_auth]
      config.ssh_check_host_key = global[:ssh_check_host_key]
    end
    ENV['GLI_DEBUG'] = 'true' if global[:trace] == true
    Dopi.logger = Logger.new(STDERR)
    Dopi.log.level = ::Logger.const_get(global[:verbosity].upcase)
    @plan_cache = DopCommon::PlanCache.new(global[:plan_cache_dir])
    true
  end


  def print_state(plan)
    plan.steps.each do |step|
      puts "[#{step.state.to_s}] #{step.name}"
      step.commands.each do |command|
        puts "  [#{command.state.to_s}] #{command.node.name}"
      end
    end
  end


  desc 'Add a new plan file to the plan cache'
  arg_name 'plan_file'
  command :add do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan file to add') if args.empty?
      help_now!('You can only add one plan') if args.length > 1
      id = @plan_cache.add(args[0])
      Dopi.load_plan(id)
      puts id
    end
  end


  desc 'Show the list of plans in the dopi plan cache'
  command :list do |c|
    c.action do |global_options,options,args|
      puts @plan_cache.list()
    end
  end


  desc 'Remove an existing plan from the plan cache'
  arg_name 'id'
  command :remove do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan id to remove') if args.empty?
      help_now!('You can only remove one plan') if args.length > 1
      puts @plan_cache.remove(args[0])
    end
  end


  desc 'Show plan details and state'
  arg_name 'id'
  command :show do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan id to show') if args.empty?
      help_now!('You can only show one plan') if args.length > 1
      print_state(Dopi.load_plan(args[0]))
    end
  end


  desc 'Run the plan'
  arg_name 'id'
  command :run do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan id to run') if args.empty?
      help_now!('You can only run one plan') if args.length > 1
      begin
        plan = Dopi.load_plan(args[0])
        plan.run
        Dopi.save_plan(plan)
        print_state(plan)
      rescue Dopi::StateTransitionError => e
        Dopi.log.error(e.message)
        exit_now!("Some steps are in a state where they can't be started again. Try to reset the plan.")
      end
    end
  end


  desc 'Reset a failed plan'
  arg_name 'id'
  command :reset do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan id to run') if args.empty?
      help_now!('You can only run one plan') if args.length > 1
      plan = Dopi.load_plan(args[0])
      plan.reset
      Dopi.save_plan(plan)
      print_state(plan)
    end
  end


  desc 'Add a plan, run it and then remove it again (This is mainly for testing)'
  arg_name 'plan_file'
  command :oneshot do |c|
    c.action do |global_options,options,args|
      help_now!('Specify a plan file to add') if args.empty?
      help_now!('You can only add one plan') if args.length > 1
      id = @plan_cache.add(args[0])
      begin
        plan = Dopi.load_plan(id)
        plan.run
        print_state(plan)
      ensure
        @plan_cache.remove(id)
      end
    end
  end

  exit run(ARGV)
end
